<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hexo部署在阿里云服务器</title>
      <link href="/2021/12/06/hexo-bu-shu-zai-a-li-yun-fu-wu-qi/"/>
      <url>/2021/12/06/hexo-bu-shu-zai-a-li-yun-fu-wu-qi/</url>
      
        <content type="html"><![CDATA[<h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h3><ol><li><p>购买阿里云的ECS服务器</p></li><li><p>注册一个域名<br> 其中包括域名购买前的实名认证。</p><p>拥有一个域名则可以直接通过域名访问网站，而不是ip地址。</p></li><li><p>域名需要进行备案</p></li></ol><h3 id="2-云服务器上的相关设置"><a href="#2-云服务器上的相关设置" class="headerlink" title="2.云服务器上的相关设置"></a>2.云服务器上的相关设置</h3><p><strong>重置实例的密码</strong></p><p><img src="https://hexo0.oss-cn-shanghai.aliyuncs.com/blog/img/image-20211206193031052.png" alt="image-20211206193031052"></p><p><strong>远程连接Linux实例</strong></p><p>通过阿里云自带的VNC进行远程连接。点击远程连接，然后选择VNC远程连接下方的立即登录。如果是第一次登陆需要重置VNC密码，之后登录。</p><p><img src="https://hexo0.oss-cn-shanghai.aliyuncs.com/blog/img/image-20211206193922280.png" alt="image-20211206193922280"></p><p>在打开的界面中输入账号，默认为root，密码为刚刚重置的实例密码，回车后进入云服务器后台.</p><p><strong>配置安全组</strong></p><p>因为我们需要通过80端口访问nginx服务，而阿里云默认禁止80端口访问权限，所以要手动添加安全组，让阿里云给相应的端口和IP放行，这样我们才能通过公网+端口的方式访问ECS服务器。</p><p><img src="https://hexo0.oss-cn-shanghai.aliyuncs.com/blog/img/image-20211206194637063.png" alt="image-20211206194637063"></p><h3 id="3-把Hexo博客部署到阿里云"><a href="#3-把Hexo博客部署到阿里云" class="headerlink" title="3.把Hexo博客部署到阿里云"></a>3.把Hexo博客部署到阿里云</h3><p>在进行下面的配置过程中要注意是在本地配置还是服务器端，是root用户还是git用户。</p><h4 id="3-1-安装nginx"><a href="#3-1-安装nginx" class="headerlink" title="3.1 安装nginx"></a>3.1 安装nginx</h4><p>我们使用nginx作为Web服务器，所以需要先安装nginx服务。具体步骤如下：</p><p>使用<strong>root用户</strong>远程登录服务器</p><p>安装nginx依赖环境，安装期间又y/n提示一律选择y。</p><pre class="line-numbers language-none"><code class="language-none">#yum install gcc-c++#yum install -y pcre pcre-devel#yum install -y zlib zlib-devel#yum install -y openssl openssl-devel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>下载nginx安装包（如果后面有出错可以换成<a href="http://nginx.org/en/download.html">官网最新的稳定版本</a> )</p><pre class="line-numbers language-none"><code class="language-none">#wget -c https://nginx.org/download/nginx-1.20.2.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将安装包解压到/usr/local目录下</p><pre class="line-numbers language-none"><code class="language-none">#tar -xvf nginx-1.20.2.tar.gz -C /usr/local<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进入/usr/local目录，确认nginx解压到该目录下</p><pre class="line-numbers language-none"><code class="language-none">#cd /usr/local#ls<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>进入nginx-1.20.2目录，会发现该目录下有一个configure文件，执行该配置文件</p><pre class="line-numbers language-none"><code class="language-none">#cd nginx-1.20.2/#ls#./configure<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>编译并安装nginx（如果这一步出错，那么就去下载最新的nginx包）</p><pre class="line-numbers language-none"><code class="language-none">#make#make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查找nginx安装目录</p><pre class="line-numbers language-none"><code class="language-none">#whereis nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进入安装目录</p><pre class="line-numbers language-none"><code class="language-none">#cd /usr/local/nginx#ls<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>由于nginx默认通过80端口访问，而Linux默认情况下不会开发该端口号，因此需要开放Linux的80端口供外部访问。</p><pre class="line-numbers language-none"><code class="language-none">#/sbin/iptables -I INPUT -p tcp –-dport 80 -j ACCEPT<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进入/usr/local/nginx/sbin目录，启动nginx</p><pre class="line-numbers language-none"><code class="language-none">#cd sbin#./nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>没有任何消息，代表启动成功。此时，便可以通过“公网IP+端口”的方式访问 <a href="http://xx.xx.xxx.xxx:80/">http://xx.xx.xxx.xxx:80/</a> 进入nginx欢迎页面了。 <strong>注：可以使用./nginx -s stop命令停止服务</strong>。</p><h4 id="3-2-配置nginx服务器路由"><a href="#3-2-配置nginx服务器路由" class="headerlink" title="3.2 配置nginx服务器路由"></a>3.2 配置nginx服务器路由</h4><p>专门为hexo创建一个部署目录/home/www/hexo,用于存放hexo生成的静态页面。</p><pre class="line-numbers language-none"><code class="language-none">#mkdir -p /home/www/hexo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进入/usr/local/nginx/conf目录，打开该文件夹下的nginx.conf配置文件。</p><pre class="line-numbers language-none"><code class="language-none">#cd /usr/local/nginx/conf#ls#vim nginx.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>进入后按insert键由命令模式切换到编辑模式。</p><ul><li><p>将其中的部署根目录（root）修改为/home/www/hexo</p></li><li><p>将域名（server_name）修改为www.域名网址，<strong>如果暂时没有域名就填阿里云实例的公网IP，以后有了再改回来</strong></p></li><li><p>查看监听端口（listen）的系统默认值是否为80（不用修改）。</p></li></ul><p>完成以上修改后，先按Esc由编辑模式切换到命令模式，再输入:wq命令保存并退出编辑器。</p><p><img src="https://hexo0.oss-cn-shanghai.aliyuncs.com/blog/img/image-20211206201125452.png" alt="image-20211206201125452"></p><h4 id="3-3-安装node-js"><a href="#3-3-安装node-js" class="headerlink" title="3.3 安装node.js"></a>3.3 安装node.js</h4><p>退回根目录，安装node.js</p><pre class="line-numbers language-none"><code class="language-none">#cd ~#curl -sL https://rpm.nodesource.com/setup_10.x | bash -#yum install -y nodejs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>查看安装结果，打印版本号即为安装成功</p><pre class="line-numbers language-none"><code class="language-none">#node -v#npm -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="3-4-安装Git"><a href="#3-4-安装Git" class="headerlink" title="3.4 安装Git"></a>3.4 安装Git</h4><p>使用yum命令安装Git，安装期间有提示一律选yes</p><pre class="line-numbers language-none"><code class="language-none">#yum install git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装成功后，查看版本号</p><pre class="line-numbers language-none"><code class="language-none">#git --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-5-创建git用户"><a href="#3-5-创建git用户" class="headerlink" title="3.5 创建git用户"></a>3.5 创建git用户</h4><p>为了实现博客的自动部署，我们后面要使用公钥免密登录服务器。为了安全起见，最好不要使用root用户免密登录。因此，我们要创建一个新的git用户，用于远程公钥免密登录服务器。</p><p>创建git用户</p><pre class="line-numbers language-none"><code class="language-none">#adduser git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改git用户的权限</p><pre class="line-numbers language-none"><code class="language-none">chmod 740 /etc/sudoers<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打开文件</p><pre class="line-numbers language-none"><code class="language-none">#vim /etc/sudoers<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进入后按insert键由命令模式切换到编辑模式。找到 root ALL=(ALL) ALL，在下面添加一行 <strong>git ALL=(ALL) ALL</strong>。修改完成后，先按Esc由编辑模式切换到命令模式，再输入:wq命令保存并退出编辑器。</p><p><img src="https://hexo0.oss-cn-shanghai.aliyuncs.com/blog/img/image-20211206201552116.png" alt="image-20211206201552116"></p><p>保存退出后改回权限</p><pre class="line-numbers language-none"><code class="language-none">#chmod 400 /etc/sudoers<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置git用户的密码</p><pre class="line-numbers language-none"><code class="language-none">#sudo passwd git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置密码：<strong>*\</strong>****<em>*</em>，这样我们就可以使用git用户远程登录阿里云服务器了。</p><h4 id="3-6-给git用户配置SSH免密公钥登录"><a href="#3-6-给git用户配置SSH免密公钥登录" class="headerlink" title="3.6 给git用户配置SSH免密公钥登录"></a>3.6 给git用户配置SSH免密公钥登录</h4><p>使用<strong>git用户</strong>免密公钥登录阿里云服务器的原理是：在本地计算机生成一个公钥文件和一个秘钥文件（类似于一个钥匙配一把锁)，然后使用FTP工具将公钥文件上传到阿里云服务器，并公钥安装到authorized_keys列表中去（即：将公钥文件的内容拷贝到authorized_keys文件中去）。这样本地计算机便可以通过ssh方式免密连接我们的阿里云服务器了。</p><p>在<strong>服务器端</strong>将登陆用户切换到git用户，然后在~目录(根目录)下创建.ssh文件夹，用来存放公钥。</p><pre class="line-numbers language-none"><code class="language-none">#su git$cd ~$mkdir .ssh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在<strong>本地计算机</strong>桌面右键打开GitBash，在本地生成公钥/私钥对(如果之前GitHub或者Gitee配置过SSH那么直接用之前的公钥就行，不用重新生成)。</p><pre class="line-numbers language-none"><code class="language-none">$cd ~$cd .ssh$ssh-keygen<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接下来，碰见系统询问就直接按回车键。此时便会在本地计算机的用户根目录（C:\Users\xxx（用户名））下自动生成.ssh（隐藏）文件夹，并在其中创建两个文件，分别为：id_rsa（私钥）和id_rsa.pub（公钥）。</p><p>在<strong>本地计算机</strong>上给私钥设置权限</p><pre class="line-numbers language-none"><code class="language-none">$ chmod 700 ~/.ssh$ chmod 600 ~/.ssh/id_rsa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>下载并安装FTP工具<a href="https://drive.google.com/file/d/185do_JQhmvuvjbmx0wvscEdYY3KCZHD0/view?usp=sharing">FileZilla</a></p><p>打开FileZilla，使用<strong>git用户</strong>通过22端口远程连接到阿里云服务器，将客服端生成的公钥上传到服务器的~/.ssh目录下。</p><p><img src="https://hexo0.oss-cn-shanghai.aliyuncs.com/blog/img/image-20211206204938014.png" alt="image-20211206204938014"></p><p>上传完成后切回<strong>服务器端</strong>，继续以<strong>git用户</strong>的身份进入服务器~/.ssh目录，新建一个authorized_keys文件，并将id_rsa.pub文件中公钥的内容拷贝到该文件中。 <strong>（注：该步骤既可以用命令行操作，也可使用FTP工具操作。）</strong></p><pre class="line-numbers language-\" data-language="\"><code class="language-\">$cd ~/.ssh$cp id_rsa.pub authorized_keys$cat id_ras.pub &gt;&gt; ~/.ssh/authorized_keys<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在服务器上设置文件权限</p><pre class="line-numbers language-none"><code class="language-none">$chmod 600 ~/.ssh/authorized_keys$chmod 700 ~/.ssh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>确保设置了正确的SELinux上下文</p><pre class="line-numbers language-none"><code class="language-none">$ restorecon -Rv ~/.ssh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在，当您使用ssh远程登录服务器时，将不会提示您输入密码（除非您在创建密钥对时输入了密码）。</p><p>接下来在本地计算机上使用ssh方式连接我们的云服务器</p><pre class="line-numbers language-none"><code class="language-none">$ssh git@xxx.xxx.xxx.xxx（阿里云公网IP）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://hexo0.oss-cn-shanghai.aliyuncs.com/blog/img/image-20211206205227726.png" alt="image-20211206205227726" style="zoom: 67%;"></p><h4 id="3-7-配置Git仓库"><a href="#3-7-配置Git仓库" class="headerlink" title="3.7 配置Git仓库"></a>3.7 配置Git仓库</h4><p>在服务器上使用git用户创建一个Git仓库，并且在该仓库中新建一个post-receive钩子文件</p><pre class="line-numbers language-none"><code class="language-none">$cd ~$git init --bare hexo.git$vi ~/hexo.git/hooks/post-receive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>进入后按insert键由命令模式切换到编辑模式。输入：</p><pre class="line-numbers language-none"><code class="language-none">git --work-tree=/home/www/hexo --git-dir=/home/git/hexo.git checkout -f<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>作用：让钩子文件删除/home/www/hexo目录下原有的文件，然后从blog.git仓库 clone 新的博客静态文件到/home/www/hexo目录下。</p><p>完成以上修改后，先按Esc由编辑模式切换到命令模式，再输入:wq命令保存并退出编辑器。</p><p>授予钩子文件可执行权限</p><pre class="line-numbers language-none"><code class="language-none">$chmod +x ~/hexo.git/hooks/post-receive$cd ~$sudo chmod -R 777 /home/www/hexo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>重启ECS服务器实例，至此就完成了所有关于服务器端的配置。</p><h3 id="4-其他配置"><a href="#4-其他配置" class="headerlink" title="4. 其他配置"></a>4. 其他配置</h3><p>配置本地博客文件目录下的config.yml文件</p><p><img src="https://hexo0.oss-cn-shanghai.aliyuncs.com/blog/img/image-20211206205725224.png" alt="image-20211206205725224"></p><p>这样在hexo d的时候就会直接把文件生成在服务器端的/home/www/hexo目录下。</p><p>在后续买好域名，并备案后，就可以修改配置文件并且正常通过域名进行访问了。</p><p>参考文档：<a href="https://mp.weixin.qq.com/s/JTTUYJTvtdT6X2fvLUBFZg">https://mp.weixin.qq.com/s/JTTUYJTvtdT6X2fvLUBFZg</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 云服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown数学公式</title>
      <link href="/2021/12/05/markdown-shu-xue-gong-shi/"/>
      <url>/2021/12/05/markdown-shu-xue-gong-shi/</url>
      
        <content type="html"><![CDATA[<p><strong>符号</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">markdown</th></tr></thead><tbody><tr><td style="text-align:center">$\times$</td><td style="text-align:center">\times</td></tr><tr><td style="text-align:center">$\cdot$</td><td style="text-align:center">\cdot</td></tr><tr><td style="text-align:center">$\bullet$</td><td style="text-align:center">\bullet</td></tr><tr><td style="text-align:center">$\partial$</td><td style="text-align:center">\partial</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td></tr></tbody></table></div><p><strong>矩阵</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">算式</th><th style="text-align:center">markdown</th></tr></thead><tbody><tr><td style="text-align:center">$\begin{matrix}0&amp;2\0&amp;0\end{matrix}$</td><td style="text-align:center">\begin{matrix}0&amp;2\0&amp;0\end{matrix}</td></tr><tr><td style="text-align:center">$\left[\begin{matrix}0&amp;2\0&amp;0\end{matrix}\right]$</td><td style="text-align:center">\left[\begin{matrix}0&amp;2\0&amp;0\end{matrix}\right]</td></tr></tbody></table></div><p><strong>上标下标</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">算式</th><th style="text-align:center">markdown</th></tr></thead><tbody><tr><td style="text-align:center">$x^2$</td><td style="text-align:center">$x^2</td></tr><tr><td style="text-align:center">$x_1$</td><td style="text-align:center">x_1</td></tr><tr><td style="text-align:center">$x^4_2$</td><td style="text-align:center">x^4_2</td></tr><tr><td style="text-align:center">$x^{y_2}$</td><td style="text-align:center">x^{y_2}</td></tr></tbody></table></div><p><strong>行内公式尽量也使用$$</strong></p>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用C++实现PSRS排序的并行计算</title>
      <link href="/2021/11/08/psrs-pai-xu/"/>
      <url>/2021/11/08/psrs-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="使用C-实现PSRS排序的并行计算"><a href="#使用C-实现PSRS排序的并行计算" class="headerlink" title="使用C++实现PSRS排序的并行计算"></a>使用C++实现PSRS排序的并行计算</h1><p>随机生成1w个数并进行排序</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;omp.h&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#define num_threads 10int *L,*R;//Merge函数合并两个子数组形成单一的已排好序的字数组//并代替当前的子数组A[p..r] //void Merge(int *a, int p, int q, int r)//{//    int i,j,k;//    int n1 = q - p + 1;//    int n2 = r - q;//    L = (int*)malloc((n1+1)*sizeof(int));//    R = (int*)malloc((n2+1)*sizeof(int));//    for(i=0; i&lt;n1; i++)//        L[i] = a[p+i];//    L[i] = 65536;//    for(j=0; j&lt;n2; j++)//        R[j] = a[q+j+1];//    R[j] = 65536;//    i=0,j=0;//    for(k=p; k&lt;=r; k++){//        if(L[i]&lt;=R[j]){//            a[k] = L[i];//            i++;//        }//        else{//            a[k] = R[j];//            j++;//        }//    }//}template&lt;typename  T&gt;void Merge(T arr[], int l, int mid, int r){    //* VS不支持动态长度数组, 即不能使用 T aux[r-l+1]的方式申请aux的空间    //* 使用VS的同学, 请使用new的方式申请aux空间    //* 使用new申请空间, 不要忘了在__merge函数的最后, delete掉申请的空间:)    T aux[r-l+1];    //T *aux = new T[r-l+1];    for( int i = l ; i &lt;= r; i ++ )        aux[i-l] = arr[i];    // 初始化，i指向左半部分的起始索引位置l；j指向右半部分起始索引位置mid+1    int i = l, j = mid+1;    for( int k = l ; k &lt;= r; k ++ ){        if( i &gt; mid ){  // 如果左半部分元素已经全部处理完毕            arr[k] = aux[j-l]; j ++;        }        else if( j &gt; r ){  // 如果右半部分元素已经全部处理完毕            arr[k] = aux[i-l]; i ++;        }        else if( aux[i-l] &lt; aux[j-l] ) {  // 左半部分所指元素 &lt; 右半部分所指元素            arr[k] = aux[i-l]; i ++;        }        else{  // 左半部分所指元素 &gt;= 右半部分所指元素            arr[k] = aux[j-l]; j ++;        }    }    //delete[] aux;} //归并排序void MergeSort(int *a, int p, int r){    if(p&lt;r){        int q = (p+r)/2;        MergeSort(a,p,q);        MergeSort(a,q+1,r);        Merge(a,p,q,r);    }} void PSRS(int *array, int n){    int id;    int i=0;    int count[num_threads][num_threads] = { 0 };    //每个处理器每段的个数    int base = n / num_threads;     //划分的每段段数    int p[num_threads*num_threads]; //正则采样数为p    int pivot[num_threads-1];       //主元    int pivot_array[num_threads][num_threads][5000]={0};  //处理器数组空间    omp_set_num_threads(num_threads);#pragma omp parallel shared(base,array,n,i,p,pivot,count) private(id)    {        id = omp_get_thread_num();        //每个处理器对所在的段进行局部串行归并排序        MergeSort(array,id*base,(id+1)*base-1);#pragma omp critical        //每个处理器选出P个样本，进行正则采样        for(int k=0; k&lt;num_threads; k++)            p[i++] = array[(id-1)*base+(k+1)*base/(num_threads+1)];//设置路障，同步队列中的所有线程#pragma omp barrier//主线程对采样的p个样本进行排序#pragma omp master        {            MergeSort(p,0,i-1);            //选出num_threads-1个主元            for(int m=0; m&lt;num_threads-1; m++)                pivot[m] = p[(m+1)*num_threads];        }#pragma omp barrier        //根据主元对每一个cpu数据段进行划分        for(int k=0; k&lt;base; k++)        {            for(int m=0; m&lt;num_threads; m++)            {                if(array[id*base+k] &lt; pivot[m])                {                    pivot_array[id][m][count[id][m]++] = array[id*base+k];                    break;                }                else if(m == num_threads-1) //最后一段                {                    pivot_array[id][m][count[id][m]++] = array[id*base+k];                }            }        }    }//向各个线程发送数据，各个线程自己排序#pragma omp parallel shared(pivot_array,count)    {        int id=omp_get_thread_num();        for(int k=0; k&lt;num_threads; k++)        {            if(k!=id)            {                memcpy(pivot_array[id][id]+count[id][id],pivot_array[k][id],sizeof(int)*count[k][id]);                count[id][id] += count[k][id];            }        }        MergeSort(pivot_array[id][id],0,count[id][id]-1);    }    i = 0;    printf("result:\n");    for(int k=0; k&lt;num_threads; k++)    {        for(int m=0; m&lt;count[k][k]; m++)        {            printf("%d ",pivot_array[k][k][m]);        }        printf("\n");    }}int* GetRandom(){    srand((unsigned int)time(0));//初始化种子为随机值    int i = 0;    static int random[10000];    for(;i &lt; 10000;++i){        int num = rand() % 100000 + 1;//产生一个1-50之间的数        //printf("%d:",i);        //printf("%d \n",num);        random[i] = num;    }    printf("\n");    return random;}int main(){    //int array[36] = {16,2,17,24,33,28,30,1,0,27,9,25,34,23,19,18,11,7,21,13,8,35,12,29,6,3,4,14,22,15,32,10,26,31,20,5};    int* array = new int[10000];    array = GetRandom();    double begin,end,time;    begin = omp_get_wtime();    PSRS(array, 10000);/*  MergeSort(list,0,35);    for(int i=0; i&lt;36; i++)    {        printf("%d ",list[i]);    }*/    end = omp_get_wtime();    time = end - begin;    printf("The running time is %lfs\n",time);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考网址：</p><p><a href="https://coding.imooc.com/learn/questiondetail/102979.html">https://coding.imooc.com/learn/questiondetail/102979.html</a></p><p><a href="https://github.com/liuyubobobo/Play-with-Algorithms/blob/master/03-Sorting-Advance/Course%20Code%20(C%2B%2B)/02-Merge-Sort/main.cpp">https://github.com/liuyubobobo/Play-with-Algorithms/blob/master/03-Sorting-Advance/Course%20Code%20(C%2B%2B)/02-Merge-Sort/main.cpp</a></p>]]></content>
      
      
      <categories>
          
          <category> 并行计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> PSRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习在图像处理中的应用</title>
      <link href="/2021/11/03/shen-du-xue-xi-zai-tu-xiang-chu-li-zhong-de-ying-yong/"/>
      <url>/2021/11/03/shen-du-xue-xi-zai-tu-xiang-chu-li-zhong-de-ying-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="深度学习在图像处理中的应用"><a href="#深度学习在图像处理中的应用" class="headerlink" title="深度学习在图像处理中的应用"></a>深度学习在图像处理中的应用</h1><p>包括图像分类（AlexNet，VGGNet，GoogLeNet，ResNet）、目标检测以及图像分割等等，使用pytorch进行实现。</p><span id="more"></span><h2 id="1-1-卷积神经网络基础"><a href="#1-1-卷积神经网络基础" class="headerlink" title="1.1 卷积神经网络基础"></a>1.1 卷积神经网络基础</h2><p>参考视频：<a href="https://www.bilibili.com/video/BV1b7411T7DA?spm_id_from=333.999.0.0">卷积神经网络</a></p><h3 id="1-1-1-全连接层"><a href="#1-1-1-全连接层" class="headerlink" title="1.1.1 全连接层"></a>1.1.1 全连接层</h3><p>全连接层，由许许多多的神经元构成而得来的。</p><p><img src="https://hexo0.oss-cn-shanghai.aliyuncs.com/blog/img/image-20211201202751850.png" alt="image-20211201202751850" style="zoom: 33%;"><br>将神经元按列进行排列，并且将列与列进行全连接，那么就能得到一个神经网络。<br>BP(back propagation)算法包括<strong>信号的前向传播</strong>和<strong>误差的反向传播</strong>两个过程。即计算误差输出时按从输入到输出的方向进行，而调整权值和阈值则从输出到输入的方向进行。</p><p>如下图的从左到右的正向传播过程中能够得到一个输出值，将这个输出值与我们期望的输出值进行对比，就能得到一个误差值</p><p><img src="https://hexo0.oss-cn-shanghai.aliyuncs.com/blog/img/image-20211201201450959.png" alt="image-20211201201450959" style="zoom: 33%;"></p><p>通过计算每一个节点的偏导数，就能得到每个节点的误差梯度，然后我们将得到的损失值反向应用到损失梯度上，就达到了误差的反向传播过程。</p><p>下面通过一个实例来解释BP神经网络：</p><p><img src="https://hexo0.oss-cn-shanghai.aliyuncs.com/blog/img/image-20211201202024109.png" alt="image-20211201202024109" style="zoom:25%;"></p><p>首先我们读入一张彩色的RGB图像，他的每个像素都含有三个值，就是三个RGB分量。</p><p><img src="https://hexo0.oss-cn-shanghai.aliyuncs.com/blog/img/image-20211201202344028.png" alt="image-20211201202344028" style="zoom:25%;"></p><p>然后将它进行灰度化处理，进行灰度化之后，如下图所示，可以看到他的每个像素都只有一个值了。</p><p><img src="https://hexo0.oss-cn-shanghai.aliyuncs.com/blog/img/image-20211201203243414.png" alt="image-20211201203243414" style="zoom:25%;"></p><p>最后进行二值化处理就得到了一个黑白图像，如下图</p><p><img src="https://hexo0.oss-cn-shanghai.aliyuncs.com/blog/img/image-20211201203503932.png" alt="image-20211201203503932" style="zoom:25%;"></p><p><img src="https://hexo0.oss-cn-shanghai.aliyuncs.com/blog/img/image-20211201203555477.png" alt="image-20211201203555477" style="zoom:25%;"></p><p>用五行三列的一个窗口在整个图像上进行滑动，每滑动一次就计算白色像素占整个像素的比例，在滑动到最右侧时要进行越界处理，最后能得到一个$5\times5$的矩阵。</p><p><img src="https://hexo0.oss-cn-shanghai.aliyuncs.com/blog/img/image-20211201204013150.png" alt="image-20211201204013150" style="zoom: 25%;"></p><p>把这个$5\times5$的矩阵按行进行展开，拼接成一个行向量。这样就可以把这个行向量当作输入到神经网络的一个<strong>输入层</strong>。</p><p><img src="https://hexo0.oss-cn-shanghai.aliyuncs.com/blog/img/image-20211201204252390.png" alt="image-20211201204252390" style="zoom: 25%;"></p><p>one-hot编码是常用的对标签进行编码的一种方式，可以保证最右侧一列每个输出的编码都不同， 这样就得到了一个<strong>输出层</strong>。</p><p>有了输入和期望的输出，就能对网络进行训练了。</p><p><img src="https://hexo0.oss-cn-shanghai.aliyuncs.com/blog/img/image-20211201204734587.png" alt="image-20211201204734587" style="zoom:33%;"></p><p>将输入层节点数设为25个，输出层设为10个，中间的隐层按情况进行设置，这样就能对神经网络进行完整的训练了。</p><h3 id="1-1-2-卷积层-CNN中独特的网络结构"><a href="#1-1-2-卷积层-CNN中独特的网络结构" class="headerlink" title="1.1.2 卷积层-CNN中独特的网络结构"></a>1.1.2 卷积层-CNN中独特的网络结构</h3><p><img src="https://hexo0.oss-cn-shanghai.aliyuncs.com/blog/img/image-20211201210505827.png" alt="image-20211201210505827" style="zoom: 33%;"></p><p>卷积就是<strong>一个滑动窗口</strong>在特征图上<strong>滑动并进行计算</strong>。如上图，以一个$3\times3$的卷积核为例，把卷积核覆盖到计算的特征层上面，也就是图中的橙色部分。将值分别进行相乘再相加，得到一个值，也就是粉色部分填写的值。这样每滑动一次能得到一个值，最后将$3\times3$的矩阵值填满也就得到了最终的卷积结果。</p><p><strong>卷积的目的是为了进行图像特征提取</strong></p><p><strong>卷积有两个特性</strong>：</p><ol><li>拥有局部感知机制：因为滑动是局部的</li><li>权值共享：因为在滑动计算过程中卷积核值是固定的</li></ol><p><img src="https://hexo0.oss-cn-shanghai.aliyuncs.com/blog/img/image-20211201211158960.png" alt="image-20211201211158960" style="zoom: 33%;"></p><p><strong>对于输入层而言，channel代表图像的通道数量，当输入图像为RGB彩色图像，则channel = 3；如果是灰度图像，则channel = 1。</strong> </p><p><strong>对于卷积核而言，卷积核的深度 = 卷积核channel数</strong></p><ul><li>若当前卷积层的上一层为输入层，则channel数 = 输入图像channel数</li><li>无论输入图像的深度是多少，每经过一个卷积核都将变换为一个深度为1的特征图，一个卷积层之内可定义多个卷积核，当前卷积层上的各个卷积核会对上一层输入的每个feature map（特征图）分别执行卷积操作，即每个卷积核都会对应生成一个新的特征图feature map(不同的卷积核所提取的特征不同)。故而在下一层需要多少个特征图，本层就需要定义多少个卷积核，所以<strong>卷积核的深度与传出的特征图的张数一致</strong>。</li></ul><p>普通的BP神经网络，假设如图中中间的隐藏层为1000个神经元，那么进行全连接时就会有921600000个参数生成。（<strong>参数指连接层之间的权重参数</strong>）</p><p>而卷积神经网络由于每个卷积核是固定的 ，一个卷积层所需要的参数就是25000个，这就体现了之前说的权值共享的特性。</p><p>前面所说的都是在一维的特征向量上进行卷积的，但实际过程中往往都是对多维的特征矩阵进行卷积操作。</p><p><img src="https://hexo0.oss-cn-shanghai.aliyuncs.com/blog/img/image-20211201212610650.png" alt="image-20211201212610650" style="zoom: 25%;"></p><p>如上图，如果输入一张彩色的RGB图像，那么就会有R G B三个分量，那么<strong>卷积核的深度也要和输入特征矩阵的深度保持一致</strong>，也要是三维。将卷积核的每个维度放在对应的维度上进行滑动卷积计算，最后再进行求和操作就得到了一个卷积层。</p><p>红色卷积核在第一个位置计算结果为0，绿色卷积核在第一个位置计算结果为0，蓝色卷积核在第一个位置计算结果为1，$0+0+1=1$，那么输出特征矩阵的第一个位置就是1，全部计算完就能得到一个输出特征矩阵。如果我们在用一组卷积核2进行计算，那么有会得到一个输出特征矩阵。将这些输出特征矩阵进行拼接那么就能得到完整的输出特征矩阵。 </p><ul><li>卷积核的深度（channel）与输入特征层的深度（channel）要相同：如图，输入的是三维的，那么卷积核也要是三维的。</li><li>输出的特征矩阵深度（channel）与卷积核个数相同：因为如图，每个卷积核都会生成一个输出特征矩阵。</li></ul><p><strong>如果加上偏移量bias那么该怎么计算呢</strong></p><p>只需要与对应的输出特征矩阵相加运算。例如上面卷积核1的偏移量为-1，那么结果就是<script type="math/tex">\begin{matrix}0&2\\0&0\end{matrix}</script>,也就是在原本的结果上加上一个偏置项（偏移量）。卷积核2的偏移量为1，那么结果就是<script type="math/tex">\begin{matrix}2&2\\3&2 \end{matrix}</script></p><p><strong>如果加上激活函数，那么又该如何进行计算呢？</strong></p><p>下面是两个常用的激活函数：</p><p><img src="https://hexo0.oss-cn-shanghai.aliyuncs.com/blog/img/image-20211201220705581.png" alt="image-20211201220705581" style="zoom: 33%;"></p><p>首先要明白<strong>为什么要使用激活函数</strong>，是因为在我们的计算过程中这是一个线性的计算过程。引入非线性因素，使其具备解决非线性问题的能力，那么就需要通过一个非线性函数来达到这个目的。</p><p>现在常用的是Relu激活函数，因为，Sigmoid激活函数<strong>达到饱和时梯度值变得非常小</strong>，当值越来越大的时候，导数就基本<strong>趋于0</strong>了。所以当网络层数较深时容易出现<strong>梯度消失</strong>，在反向传播误差的过程中导数求起来也会很麻烦。</p><p>Relu函数的<strong>导数就非常简单</strong>，当$x$小于0的时候，导数就等于0，当$x&gt;0$的时候，导数就是等于1。但它同时也有缺点，在反向传播过程中有一个<strong>非常大的梯度经过</strong>时，反向传播更新后可能会导致<strong>权重分布中心小于0</strong>，在进行正向传播时就可能会导致计算出的<strong>结果是一个小于0的数</strong>，如果小于0的话，那么经过Relu激活函数时就会<strong>被过滤掉</strong>，它的值就会始终等于0，这样它的反向传播就无法更新权重了。$x&lt;0$的梯度都为0了，反向传播过程中就无法往前进行传播了，而且<strong>权重进入失活</strong>，并且失活后就无法再被激活的。所以在训练过程当中，不要一开始就使用一个特别大的学习率进行学习，这样很可能会导致很多神经元失活。</p><p><strong>如果卷积过程中出现越界时再怎么去处理？</strong></p><p><img src="https://hexo0.oss-cn-shanghai.aliyuncs.com/blog/img/image-20211201223322907.png" alt="image-20211201223322907" style="zoom: 33%;"></p><p>如图出现越界问题时，一般通过padding的方式进行补0处理</p><p><img src="https://hexo0.oss-cn-shanghai.aliyuncs.com/blog/img/image-20211201223529902.png" alt="image-20211201223529902" style="zoom:33%;"></p><p>在卷积操作过程中，矩阵经卷积操作后的尺寸由以下几个因素决定：</p><ul><li>输入图片大小$W \times W$：图中为$4\times4$的大小</li><li>Filter（过滤器）的大小$F \times F$ ：图中为$3\times3$的大小</li><li>步长S：图中为2</li><li>padding的像素数P： 正常是左右上下各补1个P，一共2P，图中只在右边和下边补了一个P</li></ul><p>经卷积后的矩阵尺寸大小计算公式为：</p><script type="math/tex; mode=display">N=\frac{W-F+P}{S+1} =\frac{4-3+1}{2+1} =2</script><p>所以最终得到的特征矩阵的大小就为2.</p><h3 id="1-1-3-池化层"><a href="#1-1-3-池化层" class="headerlink" title="1.1.3 池化层"></a>1.1.3 池化层</h3><p><strong>池化层的目的</strong>是对特征图进行稀疏处理，减少数据运算量。</p><p>池化层和卷积层比较类似，但是与卷积层相比较会简单许多。</p><p><img src="https://hexo0.oss-cn-shanghai.aliyuncs.com/blog/img/image-20211202130739275.png" alt="image-20211202130739275" style="zoom: 33%;"></p><p>如上图就是用一个$2\times2$的池化核进行<strong>最大下采样</strong>操作，将这个池化核放在左图的第一个位置上，然后找$\begin{matrix}1&amp;1\5&amp;6 \end{matrix}$中的<strong>最大值</strong>，也就是6，于是右边输出的第一个位置就填6.</p><p><img src="https://hexo0.oss-cn-shanghai.aliyuncs.com/blog/img/image-20211202131259074.png" alt="image-20211202131259074" style="zoom:33%;"></p><p>如图是一个<strong>平均下采样层</strong>操作，与上面所说的最大下采样层最大的区别就是，拿第一个位置举例就是它是找$\begin{matrix}1&amp;1\5&amp;6 \end{matrix}$这几个数的<strong>平均值</strong>，将平均值3.25作为输出。</p><p><strong>池化层</strong>拥有以下几个<strong>特点</strong>：</p><ul><li><p>没有训练参数</p><p>卷积层的每个卷积核都会有自己的参数，像前面提到的RGB例子，每个卷积核都会有R G B三个参数。而池化层则没有参数，它只是在原本的特征层上求最大值或者平均数，也就不需要训练参数。</p></li><li><p>只改变特征矩阵的w和h，不改变深度（channel）</p><p>就如上图所示是一个$4\times4$的特征层、深度为3，用一个$2\times2$、步距（stride）为2的池化核进行计算，那么最后得到的会是一个$2\times2$、深度为3的结果。</p></li><li><p>一般池化核大小（poolsize）和步距（stride）相同，并不是绝对的。</p></li></ul><h3 id="1-1-4-误差的计算"><a href="#1-1-4-误差的计算" class="headerlink" title="1.1.4 误差的计算"></a>1.1.4 误差的计算</h3><p>以下面一个三层的BP神经网络为例</p><p><img src="https://hexo0.oss-cn-shanghai.aliyuncs.com/blog/img/image-20211204164844141.png" alt="image-20211204164844141" style="zoom:33%;"></p><p>从左往右，第一层就是输入层，有两个节点：$x_1$和$x_2$。中间为隐层，有三个节点，其中以最上面的节点为例：</p><p><img src="https://hexo0.oss-cn-shanghai.aliyuncs.com/blog/img/image-20211204165138340.png" alt="image-20211204165138340" style="zoom:33%;"></p><p>最上面这个节点的输出就是$x<em>1$乘以它对应的权重$w</em>{11}$加上$x<em>2$乘以它对应的权重$w</em>{21}$，最后加上偏置$b_1$.通过激活函数$σ$就得到了隐层的第一个节点的输出。</p><p><img src="https://hexo0.oss-cn-shanghai.aliyuncs.com/blog/img/image-20211204165831311.png" alt="image-20211204165831311" style="zoom: 33%;"></p><p>同理如上图，可以求出$y_1$和$y_2$的输出，最后一层一般用的是softmax激活函数。</p><p>因为输出的$y_1$、$y_2$不属于任意一个分布，而我们想要它<strong>满足概率分布</strong>，所以要进行softmax处理。</p><p>计算表达式如下：</p><script type="math/tex; mode=display">o_{i}=\frac{e^{y_{i}}}{\sum_{j} e^{y_{j}}}</script><p>根据表达式计算出来的结果如下：</p><script type="math/tex; mode=display">o_{1}=\frac{e^{y_{1}}}{e^{y_{1}}+e^{y_{2}}} \quad o_{2}=\frac{e^{y_{2}}}{e^{y_{1}}+e^{y_{2}}}</script><p>经过softmax处理后的所有输出节点<strong>概率和为1，</strong>即$o_1+o_2=1$。</p><p>进行<strong>交叉熵损失（Cross Entropy Loss）</strong>的计算时，针对不同问题，会有不同种的计算方法。</p><ol><li><p>针对多分类问题（softmax输出，所有输出概率和为1）</p><script type="math/tex; mode=display">H=-{\sum}_io^*_ilog(o_i)</script><p>大部分用的都是这一个，它的输出只会归为某一个类别。比如要么是猫要么是狗，不可能同时为多个。</p></li><li><p>针对二分类问题（sigmoid输出，每个输出节点之间互不相干）</p><script type="math/tex; mode=display">H=-\frac{1}{N} \sum_{i=1}^{N}\left[o_{i}^{*} \log o_{i}+\left(1-o_{i}^{*}\right) \log \left(1-o_{i}\right)\right]</script></li><li></li></ol><p>其中$o^*_i$为真实标签值，$o_i$为预测值，默认$log$以$e$为底等于$ln$</p><p>本例中是使用softmax激活函数，代入计算公式可以得到损失值：</p><script type="math/tex; mode=display">Loss=-(o_1^*log(o_1)+o_2^*log(o_2))</script><h3 id="1-1-5-误差的反向传播"><a href="#1-1-5-误差的反向传播" class="headerlink" title="1.1.5 误差的反向传播"></a>1.1.5 误差的反向传播</h3><p><img src="https://hexo0.oss-cn-shanghai.aliyuncs.com/blog/img/image-20211208111742495.png" alt="image-20211208111742495" style="zoom: 33%;"></p><p>以求<script type="math/tex">w_{11}^{(2)}</script>的误差梯度为例进行说明。它的<script type="math/tex">损失值Loss=-(o_1^*log(o_1)+o_2^*log(o_2))</script>,<script type="math/tex">\begin{aligned}概率o_{1}=\frac{e^{y_{1}}}{e^{y_{1}}+e^{y_{2}}}\end{aligned}</script></p><script type="math/tex; mode=display">\begin{aligned} 输出y_{1}=w_{11}^{(2)} \cdot \sigma\left(x_{1} \cdot w_{11}^{(1)}+x_{2} \cdot w_{21}^{(1)}+b_{1}^{(1)}\right)+\\w_{21}^{(2)} \cdot \sigma\left(x_{1} \cdot w_{12}^{(1)}+x_{2} \cdot w_{22}^{(1)}+b_{2}^{(1)}\right)+\\w_{31}^{(2)} \cdot \sigma\left(x_{1} \cdot w_{13}^{(1)}+x_{2} \cdot w_{23}^{(1)}+b_{3}^{(1)}\right)+\\b_{1}^{(2)}\end{aligned}</script><p>因为我们需要对<script type="math/tex">w_{11}^{(2)}</script>求损失梯度，那么上一个节点的输入<script type="math/tex">\sigma\left(x_{1} \cdot w_{11}^{(1)}+x_{2} \cdot w_{21}^{(1)}+b_{1}^{(1)}\right)</script>就可以看成一个常数进行处理，方便后续的计算。于是<script type="math/tex">输出y_{1}=w_{11}^{(2)} \cdot \alpha_1+w_{21}^{(2)} \cdot \alpha_2+w_{31}^{(2)} \cdot \alpha_3+b_{1}^{(2)}</script>.</p><p>求它的误差梯度也就是用损失值对它求偏导，于是<script type="math/tex">\begin{aligned}偏导数\frac{\partial \text { Loss }}{\partial w_{11}^{(2)}} =\frac{\partial L o s s}{\partial y_{1}} \cdot \frac{\partial y_{1}}{\partial w_{11}^{(2)}} =\left(\frac{\partial L o s s}{\partial o_{1}} \cdot \frac{\partial o_{1}}{\partial y_{1}}+\frac{\partial L o s s}{\partial o_{2}} \cdot \frac{\partial o_{2}}{\partial y_{1}}\right) \cdot \frac{\partial y_{1}}{\partial w_{11}^{(2)}}\end{aligned}</script></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> PyTorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git踩坑记录</title>
      <link href="/2021/10/29/git-cai-keng-ji-lu/"/>
      <url>/2021/10/29/git-cai-keng-ji-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="Git踩坑记录"><a href="#Git踩坑记录" class="headerlink" title="Git踩坑记录"></a>Git踩坑记录</h1><h3 id="gitgnore文件"><a href="#gitgnore文件" class="headerlink" title=".gitgnore文件"></a>.gitgnore文件</h3><p>.gitignore只能忽略掉那些原来没有被追踪（track）的文件，所以如果有一些文件提交到了git仓库当中，接受了git追踪,那么直接修改.gitignore是无效的。</p><p>比如一些配置文件，本地还要，直接删除仓库中的文件，也就删除了跟踪，提交上去后再配置gitignore就生效了</p><p>先执行git rm —cached public/ -r然后提交上去，后面这个文件的改动就会被忽略了,可能需要 -r</p><pre class="line-numbers language-none"><code class="language-none">git rm --cached public/ -r<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以查看在你上次提交之后是否有对文件进行再次修改，此时能看到有delete记录<br></p><pre class="line-numbers language-none"><code class="language-none">git status<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p>直接用</p><pre class="line-numbers language-none"><code class="language-none">git pull origin source<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者用下面的：</p><pre class="line-numbers language-none"><code class="language-none">git fetch origin master:temp//从远程仓库获取新版本并创建一个temp分支git diff temp //比较分支master和刚下载下来的temp分支的差异git merge temp //比较过后，你觉得没有问题就可以将temp分支合并到master分支git branch -d temp //你不想保留temp分支，就可以使用这个命令删除temp分支<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python机器学习入门</title>
      <link href="/2021/10/21/python-ji-qi-xue-xi/"/>
      <url>/2021/10/21/python-ji-qi-xue-xi/</url>
      
        <content type="html"><![CDATA[<p>机器学习就是通过算法让计算机能够从数据中提取出有用的信息，并且能够按我们的需要对它进行决策判断，最后得到我们希望得到的结果，也就是从数据-模型-预测的一个过程。</p><span id="more"></span><h2 id="机器学习概述"><a href="#机器学习概述" class="headerlink" title="机器学习概述"></a>机器学习概述</h2><h3 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h3><ul><li><p>监督学习</p><ul><li><p>定义：输入数据是由输入特征值和目标值所组成。函数的输出可以是一个连续的值（称为回归），或输出是有限个离散值（称作分类）。</p></li><li><p>目标值：类别 —— 分类问题</p><ul><li>k-近邻算法、贝叶斯分类、决策树与随机森林、逻辑回归</li></ul></li><li>目标值：连续型的数据 —— 回归问题<ul><li>线性回归、岭回归</li></ul></li></ul></li><li><p>无监督学习</p><ul><li>定义：输入数据是由输入特征值所组成。</li><li>目标值：无 —— 无监督学习<ul><li>聚类 k-means</li></ul></li></ul></li></ul><p>例：</p><ol><li>预测明天的气温是多少度？  回归</li><li>预测明天是阴、晴还是雨？  分类</li><li>人脸年龄预测？  回归/分类</li><li>人脸识别？  分类</li></ol><h3 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li>获取原始数据 - 数据集</li><li>数据预处理</li><li>特征工程 - 处理成能被算法使用的数据</li><li>选择合适的机器学习算法训练，得到模型</li><li>模型评估，查看训练的效果</li><li>模型应用</li></ol><h3 id="学习库和使用框架"><a href="#学习库和使用框架" class="headerlink" title="学习库和使用框架"></a>学习库和使用框架</h3><ul><li><p>sklearn</p></li><li><p>PyTorch</p></li><li><p>TensorFlow</p></li></ul><h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p>数据集分为训练集和测试集，通常在进行模型训练时会将数据集的训练集和测试集进行7：3分或者8：2分。</p><p>初学时可以使用sklearn里自带的数据集，它的数据量较小，方便学习。也可以通过去Kaggle等平台上进行寻找别人提供的数据集，最终大部分情况还是需要自己进行数据集的构建，利用爬虫等进行数据采集。</p><ul><li><p>sklearn数据集的简单使用：</p><p>安装库：<code>pip install Sklearn</code></p><p>然后在.py文件开头导入包：<code>from sklearn.datasets import load_iris</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> load_iris<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> train_test_split<span class="token comment"># 鸢尾花数据集查看</span><span class="token keyword">def</span> <span class="token function">getDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    iris <span class="token operator">=</span> load_iris<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 返回的是一个Bunch类型(继承自字典的类型)，所以可以用调用字典的方式去获取到相应的键值对数据</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"鸢尾花数据集：\n"</span><span class="token punctuation">,</span> iris<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"查看数据集描述：\n"</span><span class="token punctuation">,</span> iris<span class="token punctuation">[</span><span class="token string">"DESCR"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"查看特征值的名字：\n"</span><span class="token punctuation">,</span> iris<span class="token punctuation">.</span>feature_names<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"查看特征值：\n"</span><span class="token punctuation">,</span> iris<span class="token punctuation">.</span>data<span class="token punctuation">,</span> iris<span class="token punctuation">.</span>data<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>    <span class="token comment"># 数据集划分</span>    x_train<span class="token punctuation">,</span> x_test<span class="token punctuation">,</span> y_train<span class="token punctuation">,</span> y_test <span class="token operator">=</span> train_test_split<span class="token punctuation">(</span>iris<span class="token punctuation">.</span>data<span class="token punctuation">,</span> iris<span class="token punctuation">.</span>target<span class="token punctuation">,</span> test_size<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"训练集的特征值:\n"</span><span class="token punctuation">,</span> x_train<span class="token punctuation">,</span> x_train<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token boolean">None</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="特征工程介绍"><a href="#特征工程介绍" class="headerlink" title="特征工程介绍"></a>特征工程介绍</h3><p><strong>数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限而已。</strong></p><p>特征工程是使用专业背景知识和技巧处理数据，使得特征能在机器学习算法上发挥更好的作用的过程。（会直接影响机器学习的效果）</p><ul><li>pandas：用于数据清洗、数据处理</li><li>sklearn：用于特征工程处理</li></ul><p>特征工程包含下面三个内容：</p><ol><li>特征提取</li><li>特征预处理</li><li>特征降维</li></ol><h3 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h3><p>首先，机器学习算法就是一些统计方法，即一个一个的数学公式。但是这些数学公式不能直接处理例如文本的字符串数据、类型数据、图像等，所以需要把这些数据转换成数值类型。怎么样去完成这一过程就是特征提取所该做的事情。</p><p>特征提取的API：<code>sklearn.feature_extraction</code></p><h4 id="字典特征提取"><a href="#字典特征提取" class="headerlink" title="字典特征提取"></a>字典特征提取</h4><p>作用：对字典数据进行特征值化</p><ul><li>sklearn.feature_extraction.DictVectorizer(sparse=True,…)<ul><li>DictVectorizer.fit_transform(X)    X:字典或者包含字典的迭代器返回值    返回值：返回sparse矩阵</li><li>DictVectorizer.inverse_transform(X)    X:array数组或者sparse矩阵    返回值：转换之前数据格式</li><li>DictVectorizer.get_feature_names()    返回类别名称</li></ul></li></ul><p>下面为字典特征提取的一个例子</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>feature_extraction <span class="token keyword">import</span> DictVectorizer<span class="token keyword">def</span> <span class="token function">dict_demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 字典特征提取       -&gt;one-hot编码</span>    data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">'city'</span><span class="token punctuation">:</span> <span class="token string">'北京'</span><span class="token punctuation">,</span> <span class="token string">'temperature'</span><span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">'city'</span><span class="token punctuation">:</span> <span class="token string">'上海'</span><span class="token punctuation">,</span> <span class="token string">'temperature'</span><span class="token punctuation">:</span> <span class="token number">60</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">'city'</span><span class="token punctuation">:</span> <span class="token string">'深圳'</span><span class="token punctuation">,</span> <span class="token string">'temperature'</span><span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">}</span><span class="token punctuation">]</span>    <span class="token comment"># 实例化一个转换器类</span>    transfer <span class="token operator">=</span> DictVectorizer<span class="token punctuation">(</span>sparse<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>  <span class="token comment"># 默认返回的是sparse稀疏矩阵（用下标来表示位置，不表示0的位置，可以节省内存，提高加载效率），False则返回二维数组</span>    <span class="token comment"># 调用fit_transform()</span>    data_new <span class="token operator">=</span> transfer<span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>data<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"data_new：\n"</span><span class="token punctuation">,</span> data_new<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"特征名字：\n"</span><span class="token punctuation">,</span> transfer<span class="token punctuation">.</span>get_feature_names<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token boolean">None</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>one-hot编码就是对类别进行二进制化的操作，在数据集中有多少个类别特征就分成多少列，每份数据占一行，例如对下面数据进行one-hot编码：</p><div class="table-container"><table><thead><tr><th>city</th><th>temperature</th></tr></thead><tbody><tr><td>北京</td><td>100</td></tr><tr><td>上海</td><td>60</td></tr><tr><td>深圳</td><td>30</td></tr></tbody></table></div><p>最后编码后的结果就是一个二维数组：</p><div class="table-container"><table><thead><tr><th>city=上海</th><th>city=北京</th><th>city=深圳</th><th>temperature</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>0</td><td>100</td></tr><tr><td>1</td><td>0</td><td>0</td><td>60</td></tr><tr><td>0</td><td>0</td><td>1</td><td>30</td></tr></tbody></table></div><h4 id="文本特征提取"><a href="#文本特征提取" class="headerlink" title="文本特征提取"></a>文本特征提取</h4><p>作用：对文本数据进行特征值化</p><ul><li>sklearn.feature_extraction.text.CountVectorizer(stop_words=[])    返回词频矩阵</li><li>CountVectorizer.fit_transform(X)    X:文本或者包含文本字符串的可迭代对象    返回值：返回sparse矩阵</li><li>CountVectorizer.inverse_transform(X)    X:array数组或者sparse矩阵    返回值：转换之前数据格式</li><li>CountVectorizer.get_feature_names()    返回值：单词列表</li><li>sklearn.feature_extraction.text.TfidfVectorizer</li></ul><p>一般是把一个个单词作为特征，也叫特征词。</p><p>例如对下面数据进行特征提取：</p><pre class="line-numbers language-none"><code class="language-none">["life is short,i like python",life is too long ,i dislike python]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提取以后的结果就是：</p><pre class="line-numbers language-none"><code class="language-none">['dislike','is','life','like',long','python','short','too'][[0 1 1 1 0 1 1 0] [1 1 1 0 1 1 0 1]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>下面是调用CountVectorizer的实例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">count_demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    文本特征抽取：CountVecotrizer    :return:    """</span>    data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"life is short,i like like python"</span><span class="token punctuation">,</span> <span class="token string">"life is too long,i dislike python"</span><span class="token punctuation">]</span>    <span class="token comment"># 1、实例化一个转换器类</span>    transfer <span class="token operator">=</span> CountVectorizer<span class="token punctuation">(</span>stop_words<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"is"</span><span class="token punctuation">,</span> <span class="token string">"too"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment"># 2、调用fit_transform</span>    data_new <span class="token operator">=</span> transfer<span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>data<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"data_new:\n"</span><span class="token punctuation">,</span> data_new<span class="token punctuation">.</span>toarray<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 通过.toarray转成数组</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"特征名字：\n"</span><span class="token punctuation">,</span> transfer<span class="token punctuation">.</span>get_feature_names<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token boolean">None</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于一段英文可以通过这种方式进行简单的特征提取，但是如果对象是一段中文那么问题就来了。例如下面这个例子：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">count_chinese_demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    中文文本特征抽取：CountVecotrizer    :return:    """</span>    data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"我爱北京天安门"</span><span class="token punctuation">,</span> <span class="token string">"天安门上太阳升"</span><span class="token punctuation">]</span>    <span class="token comment"># 1、实例化一个转换器类</span>    transfer <span class="token operator">=</span> CountVectorizer<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 2、调用fit_transform</span>    data_new <span class="token operator">=</span> transfer<span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>data<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"data_new:\n"</span><span class="token punctuation">,</span> data_new<span class="token punctuation">.</span>toarray<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"特征名字：\n"</span><span class="token punctuation">,</span> transfer<span class="token punctuation">.</span>get_feature_names<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token boolean">None</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果如下：</p><pre class="line-numbers language-none"><code class="language-none">data_new: [[0 1] [1 0]]特征名字： ['天安门上太阳升', '我爱北京天安门']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，返回的结果并不是我们想要的，因为它直接把两句话当成了特征词，而我们需要的是把一个个词作为特征词，那么得需要将上面的data改成<code>data = ["我 爱 北京 天安门", "天安门 上 太阳 升"]</code>，手动添加空格进行分割，这样才能按我们需求返回特征，也就是如下的结果：</p><pre class="line-numbers language-none"><code class="language-none">data_new: [[1 1 0] [0 1 1]]特征名字： ['北京', '天安门', '太阳']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="jieba分词处理"><a href="#jieba分词处理" class="headerlink" title="jieba分词处理"></a>jieba分词处理</h4><p>想要对中文更加有效的进行分词的话，我们则需要使用到jieba分词。</p><p>很简单，先安装jieba库<code>pip install jieba</code>，然后只需要调用<code>jieba.cut()</code>，则会返回词语组成的生成器。</p><p>下面是一个实例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">cut_word</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    进行中文分词："我爱北京天安门" --&gt; "我 爱 北京 天安门"    :param text:    :return:    """</span>    <span class="token keyword">return</span> <span class="token string">" "</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">(</span>jieba<span class="token punctuation">.</span>cut<span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">count_chinese_demo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    中文文本特征抽取，自动分词    :return:    """</span>    <span class="token comment"># 将中文文本进行分词</span>    data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"一种还是一种今天很残酷，明天更残酷，后天很美好，但绝对大部分是死在明天晚上，所以每个人不要放弃今天。"</span><span class="token punctuation">,</span>            <span class="token string">"我们看到的从很远星系来的光是在几百万年之前发出的，这样当我们看到宇宙时，我们是在看它的过去。"</span><span class="token punctuation">,</span>            <span class="token string">"如果只用一种方式了解某样事物，你就不会真正了解它。了解事物真正含义的秘密取决于如何将其与我们所了解的事物相联系。"</span><span class="token punctuation">]</span>    data_new <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> sent <span class="token keyword">in</span> data<span class="token punctuation">:</span>        data_new<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cut_word<span class="token punctuation">(</span>sent<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># print(data_new)</span>    <span class="token comment"># 1、实例化一个转换器类</span>    transfer <span class="token operator">=</span> CountVectorizer<span class="token punctuation">(</span>stop_words<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"一种"</span><span class="token punctuation">,</span> <span class="token string">"所以"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment"># 2、调用fit_transform</span>    data_final <span class="token operator">=</span> transfer<span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>data_new<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"data_new:\n"</span><span class="token punctuation">,</span> data_final<span class="token punctuation">.</span>toarray<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"特征名字：\n"</span><span class="token punctuation">,</span> transfer<span class="token punctuation">.</span>get_feature_names<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token boolean">None</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo搭建及维护</title>
      <link href="/2021/10/20/hexo-da-jian-ji-wei-hu/"/>
      <url>/2021/10/20/hexo-da-jian-ji-wei-hu/</url>
      
        <content type="html"><![CDATA[<h1 id="基于Hexo的博客搭建及维护"><a href="#基于Hexo的博客搭建及维护" class="headerlink" title="基于Hexo的博客搭建及维护"></a>基于Hexo的博客搭建及维护</h1><p>本文将说明如何搭建一个自己的Hexo博客，以及后续如何对该博客进行维护。</p><hr><h2 id="基础搭建"><a href="#基础搭建" class="headerlink" title="基础搭建"></a>基础搭建</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>安装以下应用：</p><ul><li><a href="http://git-scm.com/">Git</a></li><li><a href="https://nodejs.org/en/">Node.js</a></li></ul><p>安装完成以后可以通过命令行的方式查看版本号</p><p>打开CMD</p><pre class="line-numbers language-none"><code class="language-none">git --version   # 查看git版本号node# 查看node.js版本号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>都能正确显示则表示可以进行下一步了。</p><h3 id="Hexo的安装"><a href="#Hexo的安装" class="headerlink" title="Hexo的安装"></a>Hexo的安装</h3><p>新建一个文件夹，后续所有操作都在此文件夹下进行。</p><p>安装淘宝的cnpm管理器，可能会提升后续的安装速度（可选），如安装失败则后续还是使用npm进行安装</p><pre class="line-numbers language-none"><code class="language-none">npm -vnpm install -g cnpm --registry=http://registry.npm.taobao.orgcnpm -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用npm或者cnpm安装Hexo框架</p><pre class="line-numbers language-none"><code class="language-none">npm install -g hexo-clihexo -v# 查看hexo版本信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>初始化一个博客</p><pre class="line-numbers language-none"><code class="language-none">hexo init# 初始化博客hexo s# 启动本地blog服务http://localhost:4000/ # 本地访问网页的地址，可以查看初始效果<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="通过把博客部署到Github以及Gitee上来进行访问"><a href="#通过把博客部署到Github以及Gitee上来进行访问" class="headerlink" title="通过把博客部署到Github以及Gitee上来进行访问"></a>通过把博客部署到Github以及Gitee上来进行访问</h3><p>配置文件夹中的配置文件_config.yml：</p>  <pre class="line-numbers language-none"><code class="language-none"># Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy:  type: 'git'  repo:    github: git@github.com:aik-n/aik-n.github.io.git    gitee: git@gitee.com:aik-n/aik-n.github.io.git  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  该配置文件因同时给定了两个地址，所以下面在部署时会同时部署到两边。</p><ul><li><p><strong>部署在Github上</strong></p><p>在Github上创建一个新的仓库（以自己的为例）aik-n.github.io</p><p>然后在文件夹中安装git部署插件</p><pre class="line-numbers language-none"><code class="language-none">npm install --save hexo-deployer-git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后通过hexo命令将博客部署到Github的仓库中去</p><pre class="line-numbers language-none"><code class="language-none">hexo clean# 清理一下hexo g# 生成hexo d# 部署到远程Git仓库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>即可通过<a href="https://aik-n.github.io/来访问自己的博客">https://aik-n.github.io/来访问自己的博客</a></p></li><li><p>部署在Gitee上</p><p>在Gitee上创建一个新的仓库，名字自己取（<strong>建议用用户名，后面会说明原因</strong>）</p><p>然后在文件夹中安装git部署插件（上面安装过了这边就不用了）</p><pre class="line-numbers language-none"><code class="language-none">npm install --save hexo-deployer-git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后通过hexo命令将博客部署到Gitee的仓库中去</p><pre class="line-numbers language-none"><code class="language-none">hexo clean# 清理一下hexo g# 生成hexo d# 部署到远程Git仓库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>即可通过<a href="https://aik-n.gitee.io/blog来访问自己的博客">https://aik-n.gitee.io/blog来访问自己的博客</a></p><p><strong>注：</strong>如果打开的页面无css样式，有以下解决方法：</p><p><strong>方法一</strong>：需要去配置文件_config.yml中修改参数</p><pre class="line-numbers language-none"><code class="language-none"># URL## Set your site url here. For example, if you use GitHub Page, set url as 'https://username.github.io/project'url: https://gitee.com/aik-n/blog.gitroot: /blog<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但这样会出现一个问题，就是地址和路径只能填一个，导致如果同时在GitHub和Gitee上部署的话会有一边无法加载出Css样式，建议采用下面的方法。</p><p><strong>方法二</strong>：通过建立一个与自己个性仓库同名的仓库，如<a href="https://gitee.com/aik-n这个用户，创建站点并且不想以子目录的方式访问，那么就可以创建名为aik-n的仓库https://gitee.com/aik-n/aik-n，这样再部署完成后就可以直接通过https://aik-n.gitee.io进行访问。">https://gitee.com/aik-n这个用户，创建站点并且不想以子目录的方式访问，那么就可以创建名为aik-n的仓库https://gitee.com/aik-n/aik-n，这样再部署完成后就可以直接通过https://aik-n.gitee.io进行访问。</a></p></li></ul><hr><h2 id="后续维护"><a href="#后续维护" class="headerlink" title="后续维护"></a>后续维护</h2><p>此时在Github上查看仓库中的文件可以发现和本地的文件并不相同，它只包含了网页的静态页面，像是主题以及文章源文件都是不在里面的。因此我们需要将源文件也上传到仓库里去，这样才能方便我们后续的维护工作。</p><h3 id="SSH配置"><a href="#SSH配置" class="headerlink" title="SSH配置"></a>SSH配置</h3><p>以本人电脑为例：C:\Users\xwy.ssh目录下存放着公钥和密钥的文件信息。如果没配过的就把这文件夹下的全都删了，从头配起。</p><p>ssh文件夹右键，打开Git Bash窗口。</p><p>如果你是第一次使用，或者还没有配置过的话需要操作一下命令，自行替换相应字段。</p><pre class="line-numbers language-git" data-language="git"><code class="language-git">git config --global user.name <span class="token string">"XXX"</span>git config --global user.email  <span class="token string">"XXX@gmail.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><p><strong>GitHub</strong></p><p>在终端中输入：</p><pre class="line-numbers language-none"><code class="language-none">ssh-keygen -t rsa -C "xxx@gmail.com"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>按三次回车，则会在当前目录下生成rsa开头的两个文件，打开rsa.pub文件，里面就是公钥，复制到Github里的SSH设置里去。</p><p>验证一下是否连接：</p><pre class="line-numbers language-none"><code class="language-none">ssh -T git@github.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>首次需要回复yes然后回车，如果成功则会有Hi XXX! You’ve successfully authenticated, but Github.com does not provide shell access.的内容返回。</p></li><li><p><strong>Gitee</strong></p><p>在终端中输入：</p><pre class="line-numbers language-none"><code class="language-none">ssh-keygen -t ed25519 -C "xxxxx@xxxxx.com"  # 这里邮箱填注册用到的邮箱<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>按三次回车，则会在当前目录下生成ed25519开头的两个文件，打开id_ed25519.pub文件，里面就是公钥，复制到Gitee里的SSH设置里去。</p><p>验证一下是否连接：</p><pre class="line-numbers language-none"><code class="language-none">ssh -T git@gitee.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>首次需要回复yes再回车，如果成功则会有Hi XXX! You’ve successfully authenticated, but Gitee.com does not provide shell access.的内容返回</p></li></ul><p>如果以上都配置好了但还是有错误提示的话，建议采用如下方法：</p><ul><li><p>在ssh文件夹中建立一个<strong>config</strong>文件（没有后缀名），内容如下：</p><pre class="line-numbers language-none"><code class="language-none"># giteeHost gitee.comHostName gitee.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_ed25519# githubHost github.comHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/github_id_rsa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>里面的文件地址自行修改，之后再进行上述的验证操作。</p></li></ul><h3 id="备份至仓库分支上"><a href="#备份至仓库分支上" class="headerlink" title="备份至仓库分支上"></a>备份至仓库分支上</h3><h4 id="直接备份"><a href="#直接备份" class="headerlink" title="直接备份"></a>直接备份</h4><p>在Github/Gitee博客的仓库中创建一个分支<strong>source</strong>,并将其设置为默认分支</p><p>在博客的文件目录下打开Git Bash</p><p>查看一下本地分支：</p><pre class="line-numbers language-none"><code class="language-none">git branch -a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中绿色前面一个*的代表当前所处的分支，红色代表关联的远程分支，白色的代表存在的其他本地分支。</p><p>之后创建一个本地分支source，对应仓库里存放备份文件的分支：</p><pre class="line-numbers language-none"><code class="language-none">git branch source<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果创建了多个分支，可以通过下面来进行切换：</p><pre class="line-numbers language-none"><code class="language-none">git checkout 想要切换的分支名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在创建并切换到source分支后，开始将本地分支推到Git上：</p><pre class="line-numbers language-none"><code class="language-none">git init# 建立本地git仓库git remote add origin https://xxx@xx.git # （将本地的仓库关联到GitHub（码云）上对应的仓库，后面的https改成仓库地址git add .git commit -m"提交信息"git push origin source #代表把本地source分支的内容推到Github上仓库里的source下，创建新分支后的第一次需要加上-f强推<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，其中git remote add origin 中的origin可以自己修改的，代表远程地址的别名，例如我想将本地仓库同时关联GitHub和Gitee，那么我可以执行下面两行：</p><pre class="line-numbers language-none"><code class="language-none">git remote add origin https://gitee.com/aik-n/aik-n.github.io.gitgit remote add origin1 https://github.com/aik-n/aik-n.github.io.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>一个origin，一个origin1。这样在push的时候，我们就可以选择往哪个上面推。</p><p>我们可以使用Git remote命令来查看相关信息：</p><pre class="line-numbers language-none"><code class="language-none">git remote -v# 可以查看远程仓库列表，有关联则会在下面都列出来git remote show 仓库别名# 可以查看该仓库的详细信息git remote add 仓库别名 仓库地址# 关联远程仓库git remote rm 仓库别名# 删除仓库git remote rename 老别名 新别名# 修改仓库名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="使用Hexo插件备份"><a href="#使用Hexo插件备份" class="headerlink" title="使用Hexo插件备份"></a>使用Hexo插件备份</h4><p>利用Hexo框架自带的hexo-git-backup插件进行快捷备份。</p><p>安装插件：</p><pre class="line-numbers language-none"><code class="language-none">npm install hexo-git-backup --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置博客目录的_config.yml文件</p><pre class="line-numbers language-none"><code class="language-none">backup:  type: git       message: hexo blog source     repository:      github: git@github.com:aik-n/aik-n.github.io.git,source #这里改成你自己的，分钟“source”也改成自己的，如果Github不存在会自动新建    gitee: git@gitee.com:aik-n/aik-n.github.io.git,source #这里改成你自己的，分钟“source”也改成自己的，如果Gitee不存在会自动新建<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行备份：</p><pre class="line-numbers language-none"><code class="language-none">hexo backup<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="更换新的电脑后"><a href="#更换新的电脑后" class="headerlink" title="更换新的电脑后"></a>更换新的电脑后</h2><p>在更换设备之后，我们只需要重新配置一下环境，然后把备份的项目从GitHub上拉下来就行了。</p><ol><li><p>下载<a href="http://git-scm.com/">Git</a>和<a href="https://nodejs.org/en/">Node.js</a>并安装</p></li><li><p><code>git clone 仓库地址</code></p><p>或者直接把项目包下载下来解压</p></li><li><p>在项目文件夹中安装Hexo框架以及后续部署使用的git部署插件，<strong>切记不要用<del>hexo init</del>把项目初始化了</strong>。</p><pre class="line-numbers language-none"><code class="language-none">npm installnpm install -g hexo-cli# Hexo框架安装（这一步可能不需要）npm install --save hexo-deployer-git# git部署插件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>之后由于配置文件都是直接从云拉下来的，所以不用再进行更改了，直接hexo三联进行部署，git push进行后续维护，在进行备份时，记得配置好下面这两项：</p><pre class="line-numbers language-git" data-language="git"><code class="language-git">git config --global user.name <span class="token string">"XXX"</span>git config --global user.email  <span class="token string">"XXX@gmail.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可能也还需要配置SSH</p></li></ol><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>Hexo的源文件说明：</p><ol><li><code>_config.yml</code>站点的配置文件，需要拷贝；</li></ol><ol><li><code>themes/</code>主题文件夹，需要拷贝；</li><li><code>source</code>博客文章的.md文件，需要拷贝；</li><li><code>scaffolds/</code>文章的模板，需要拷贝；</li><li><code>package.json</code>安装包的名称，需要拷贝；</li><li><p><code>.gitignore</code>限定在push时哪些文件可以忽略，需要拷贝；</p></li><li><p><code>.git/</code>主题和站点都有，标志这是一个git项目，不需要拷贝；</p></li><li><p><code>node_modules/</code>是安装包的目录，在执行npm install的时候会重新生成，不需要拷贝；</p></li><li><p><code>public</code>是hexo g生成的静态网页，不需要拷贝；</p></li><li><p><code>.deploy_git</code>同上，hexo g也会生成，不需要拷贝；</p></li><li><p><code>db.json</code>文件，不需要拷贝。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Hexo </tag>
            
            <tag> node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo踩坑记录</title>
      <link href="/2021/10/20/hexo-cai-keng-ji-lu/"/>
      <url>/2021/10/20/hexo-cai-keng-ji-lu/</url>
      
        <content type="html"><![CDATA[<p><strong>hexo使用theme出现<code>“ {% extends ‘_layout.swig‘ %} {% import ‘_macro/post.swig‘ as post_template %}“</code>问题</strong></p><p>原因是hexo在5.0之后把swig给删除了需要自己手动安装</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">npm i hexo<span class="token operator">-</span>renderer<span class="token operator">-</span>swig<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>hexo出现以下报错</strong></p><pre class="line-numbers language-none"><code class="language-none">INFO  Validating configINFO  Start processingFATAL {  err: Template render error: (unknown path)    Error: template names must be a string: undefined      at Object._prettifyError (D:\DataSource\blog\node_modules\nunjucks\src\lib.js:36:11)      at D:\DataSource\blog\node_modules\nunjucks\src\environment.js:563:19<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>多半是因为markdown文件中有大括号，要么不用，要么转义字符&amp;#123和&amp;#125</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Hexo </tag>
            
            <tag> node.js </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
